{"version":3,"sources":["components/PlayButton.js","components/NN.js","components/ScatterPlot.js","App.js","reportWebVitals.js","index.js"],"names":["PlayButton","playing","Fab","style","background","color","Stop","PlayArrow","NN","props","state","initNeuralNetwork","bind","node","this","shape","weights","slowed","svg","xScale","d3","domain","range","yScale","start","x","y","stop","link","d","rw","rh","layerProportion","ns","flatns","push","layer","length","dense","neuron","aaron","links","prevNeuron","source","target","flattenedWeights","flatten","selectAll","data","enter","append","attr","Math","pow","array","flattendArray","i","e","weightModel","revereseFlatten","console","log","weightsIndex","connections","connectionArray","w","reverse","select","children","id","Component","ScatterPlot","formattedPoints","a","width","height","padding","X","container","xAxis","scale","yAxis","call","yhat","dataSet","remove","plotPoints","App","biasData","weightsData","model","seq","neurons","loss","dlossdyhat","epoch","lr","curve","optimizer","controls","speed","main","run","neuralNetwork","initDenseNeuron","initializeModel","linkModel","forwardModel","backwardModel","updateModel","setInputs","generateData","genTensorData","linearData","mutate","mutateModelNeurons","passBack","mutateAllBackward","train","printParameters","reset","asyncPause","resetParameters","changeModelLr","changeModelOptimizer","optimizerChange","modelCompile","lrChange","optimizer_","learningRate","number","max","array1","array2","map","item","reduce","b","floor","random","timer","ms","Promise","res","setTimeout","getRandomInt","increment","eqn","newShape","numLayers","numNeurons","numInputs","DenseNeuronTemplate","forward","inputs","bias","product","sum","activation","output","backward","dvalue","dReLU","dBias","dMult","dWeights","dInputs","dNeuron","index","io","mult","ReLU","relu","mseLoss","currentLayer","prevLayer","outputLayerIndex","dyhat","mseDerivative","dNeurons","dNeuronsSum","param","dparam","updatedWeights","weight","gradientDescent","updatedBias","equation","undefined","input","toFixed","error","end","key","subkey","value","setState","tensor","Array","from","dataSync","add","tf","inputShape","units","useBias","addModel","compile","play","fit","epochs","h","history","predict","tensorToArray","scaled","XTensor","yTensor","yhatTensor","weightSet","biasSet","getWeights","adam","sgd","splice","lrs","dataSets","label","PlayButtonClick","onClick","AppBar","position","Toolbar","Typography","variant","Box","display","justifyContent","marginTop","Card","CardContent","CardActions","IconButton","disabled","Replay","SlowMotionVideo","Chip","num","marginLeft","biases","minWidth","marginRight","Button","marginBottom","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0d16ff59.chunk.js","sourcesContent":["/* \n\tDonny Bertucci: @xnought\n\tDate Created: 02/15/2021\n\tSummary: \n\t\tFunctional Component for PlayButton\n\t@Props: playing: false or true\n*/\nimport { Fab } from \"@material-ui/core\";\nimport { PlayArrow, Stop } from \"@material-ui/icons\";\n\nconst PlayButton = ({ playing }) => (\n\t<Fab\n\t\tstyle={{\n\t\t\tbackground: playing ? \"#f44336\" : \"#4caf50\",\n\t\t\tcolor: \"#FFFFFF\",\n\t\t}}\n\t>\n\t\t{playing ? <Stop /> : <PlayArrow />}\n\t</Fab>\n);\n\nexport default PlayButton;\n","import React, { Component } from \"react\";\nimport * as d3 from \"d3\";\nclass NN extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {};\n\t\tthis.initNeuralNetwork = this.initNeuralNetwork.bind(this);\n\t}\n\tinitNeuralNetwork(node) {\n\t\tconst { playing, shape, weights, slowed } = this.props;\n\t\tconst rw = 32;\n\t\tconst rh = 32;\n\t\tconst svg = node;\n\t\tlet xScale = d3.scaleLinear().domain([0, 100]).range([50, 750]);\n\n\t\tlet yScale = d3.scaleLinear().domain([0, 100]).range([500, 0]);\n\n\t\tlet start = { x: 50 - rw / 2, y: 250 - rh / 2 };\n\t\tlet stop = { x: 750 - rw / 2, y: 250 - rh / 2 };\n\n\t\tconst link = d3\n\t\t\t.linkHorizontal()\n\t\t\t.x((d) => d.x + rw / 2)\n\t\t\t.y((d) => d.y + rh / 2);\n\n\t\t/* First we figure our how to create the neurons */\n\t\t/* GIVEN A SHAPE OF [1,2,2,1] */\n\t\tconst layerProportion = [0, 25, 50, 75, 0];\n\t\tlet ns = [];\n\t\tlet flatns = [];\n\t\tns.push([start]);\n\t\tflatns.push(start);\n\t\tfor (let layer = 1; layer < shape.length - 1; layer++) {\n\t\t\tlet dense = [];\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t/* First generate neuron */\n\t\t\t\tlet aaron = {\n\t\t\t\t\tx: xScale(layerProportion[layer]) - rw / 2,\n\t\t\t\t\ty: yScale(92 - neuron * 12) - rh / 2,\n\t\t\t\t};\n\t\t\t\tdense.push(aaron);\n\t\t\t\tflatns.push(aaron);\n\t\t\t}\n\t\t\tns.push(dense);\n\t\t}\n\t\tflatns.push(stop);\n\t\tns.push([stop]);\n\n\t\t/* We start to iterate over ns */\n\t\tlet links = [];\n\t\tfor (let layer = shape.length - 1; layer > 0; layer--) {\n\t\t\tfor (\n\t\t\t\tlet prevNeuron = 0;\n\t\t\t\tprevNeuron < shape[layer - 1];\n\t\t\t\tprevNeuron++\n\t\t\t) {\n\t\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t\tlinks.push(\n\t\t\t\t\t\tlink({\n\t\t\t\t\t\t\tsource: ns[layer - 1][prevNeuron],\n\t\t\t\t\t\t\ttarget: ns[layer][neuron],\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet flattenedWeights = this.flatten(weights);\n\n\t\tsvg.selectAll(\"path\")\n\t\t\t.data(links)\n\t\t\t.enter()\n\t\t\t.append(\"path\")\n\t\t\t.attr(\"fill\", \"none\")\n\t\t\t.attr(\"class\", \"edgeForward\")\n\t\t\t.attr(\"stroke-width\", \"0.5\")\n\t\t\t.attr(\"d\", (d) => d);\n\t\tsvg.selectAll(\"path\")\n\t\t\t.data(flattenedWeights)\n\t\t\t.attr(\"stroke-width\", (d) => Math.pow(d, 2) + 0.2);\n\n\t\tsvg.selectAll(\"rect\")\n\t\t\t.data(flatns)\n\t\t\t.enter()\n\t\t\t.append(\"rect\")\n\t\t\t.attr(\"x\", (d) => d.x)\n\t\t\t.attr(\"y\", (d) => d.y)\n\t\t\t.attr(\"width\", rw)\n\t\t\t.attr(\"height\", rh)\n\t\t\t.attr(\"class\", \"node\");\n\n\t\tif (!playing) {\n\t\t\tsvg.selectAll(\"path\").attr(\"class\", \"edgePaused\");\n\t\t} else if (playing) {\n\t\t\tsvg.selectAll(\"path\").attr(\n\t\t\t\t\"class\",\n\t\t\t\tslowed ? \"edgeSlowed\" : \"edgeForward\"\n\t\t\t);\n\t\t}\n\t}\n\tcomponentDidMount() {\n\t\tconst height = 500;\n\t\tconst width = 800;\n\t\tconst svg = d3\n\t\t\t.select(\"#nn\")\n\t\t\t.append(\"svg\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height)\n\t\t\t.attr(\"overflow\", \"visible\");\n\t\t//svg.append(\"circle\").attr(\"r\", 1000);\n\n\t\tthis.initNeuralNetwork(svg);\n\t}\n\tflatten(array) {\n\t\tlet flattendArray = [];\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tfor (let e = 0; e < array[i].length; e++) {\n\t\t\t\tflattendArray.push(array[i][e]);\n\t\t\t}\n\t\t}\n\t\treturn flattendArray;\n\t}\n\trevereseFlatten(array) {\n\t\tlet flattendArray = [];\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tfor (let e = 0; e < array[i].length; e++) {\n\t\t\t\tflattendArray.push(array[i][e]);\n\t\t\t}\n\t\t}\n\t\treturn flattendArray;\n\t}\n\tperNeuron(weights, shape) {\n\t\tlet weightModel = [];\n\t\tif (weights.length > 0) {\n\t\t\tlet flattenedWeights = this.revereseFlatten(weights);\n\t\t\tconsole.log(flattenedWeights);\n\t\t\tconsole.log(weights);\n\t\t\tlet weightsIndex = 0;\n\t\t\t/* Iterate but not the input node */\n\t\t\t/*  this is an ass algo fix this you idiot  */\n\t\t\tfor (let layer = shape.length - 1; layer > 0; layer--) {\n\t\t\t\t/* Now we want to assign the weight based on number of inputs */\n\t\t\t\tlet dense = [];\n\t\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t\tlet connections = shape[layer - 1];\n\t\t\t\t\tlet connectionArray = [];\n\t\t\t\t\tfor (let w = 0; w < connections; w++) {\n\t\t\t\t\t\tconnectionArray.push(flattenedWeights[weightsIndex]);\n\t\t\t\t\t\tweightsIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tdense.push(connectionArray);\n\t\t\t\t}\n\t\t\t\tweightModel.push(dense);\n\t\t\t}\n\t\t}\n\t\treturn weightModel.reverse();\n\t}\n\tcomponentDidUpdate() {\n\t\tconst svg = d3.select(\"#nn\").select(\"svg\");\n\t\tthis.initNeuralNetwork(svg);\n\n\t\t/* If there is a change to shape do these things */\n\t\t/* First need to create a function to places all of the neurons */\n\t\t/* then need to create a function to that links all of the neurons with stroke */\n\n\t\t/* If there is no change to shape then we just need to change the link stroke */\n\t}\n\trender() {\n\t\tconst { children } = this.props;\n\t\treturn <div id=\"nn\">{children}</div>;\n\t}\n}\n\nexport default NN;\n","import React, { Component } from \"react\";\nimport style from \"./d3.css\";\nimport * as d3 from \"d3\";\n\nclass ScatterPlot extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {};\n\t}\n\n\tplotPoints(node, formattedPoints) {\n\t\t/* Now need to plot said data */\n\t\tnode.selectAll(\"circle\")\n\t\t\t.data(formattedPoints)\n\t\t\t.enter()\n\t\t\t.append(\"circle\")\n\t\t\t.attr(\"cx\", (d) => d.x)\n\t\t\t.attr(\"cy\", (d) => d.y)\n\t\t\t.attr(\"r\", 2)\n\t\t\t.style(\"fill\", \"#F50257\");\n\t}\n\t/* This is where we initialize the Scatter Plot */\n\tasync componentDidMount() {\n\t\tconst { width, height, padding, start, stop, X, y } = this.props;\n\t\tconst container = d3.select(\"#nice\");\n\n\t\tconst svg = container\n\t\t\t.append(\"svg\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height)\n\t\t\t.style(\"overflow\", \"visible\");\n\t\tsvg.append(\"rect\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height)\n\t\t\t.attr(\"class\", \"cord\");\n\t\tlet xScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([0, width - 2 * padding]);\n\n\t\tlet yScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([height - 2 * padding, 0]);\n\n\t\tlet xAxis = d3.axisBottom().scale(xScale);\n\t\tlet yAxis = d3.axisRight().scale(yScale);\n\t\tsvg.append(\"g\")\n\t\t\t.attr(\"class\", \"axis\")\n\t\t\t.attr(\"transform\", `translate(0,${height - 2 * padding})`)\n\t\t\t.call(xAxis);\n\n\t\tsvg.append(\"g\")\n\t\t\t.attr(\"class\", \"axis\")\n\t\t\t.attr(\"transform\", \"translate(\" + (width - 2 * padding) + \",0)\")\n\t\t\t.call(yAxis);\n\n\t\tsvg.append(\"line\")\n\t\t\t.attr(\"x1\", 0)\n\t\t\t.attr(\"y1\", (height + 1) / 2)\n\t\t\t.attr(\"x2\", width)\n\t\t\t.attr(\"y2\", (height + 1) / 2)\n\t\t\t.attr(\"class\", \"split\");\n\t\tsvg.append(\"line\")\n\t\t\t.attr(\"x1\", (width + 1) / 2)\n\t\t\t.attr(\"y1\", 0)\n\t\t\t.attr(\"x2\", (width + 1) / 2)\n\t\t\t.attr(\"y2\", height)\n\t\t\t.attr(\"class\", \"split\");\n\n\t\tsvg.append(\"path\")\n\t\t\t.attr(\"id\", \"epic\")\n\t\t\t.attr(\"stroke\", \"none\")\n\t\t\t.attr(\"fill\", \"none\");\n\t}\n\tcomponentDidUpdate() {\n\t\tconst { width, height, padding, start, stop, X, y, yhat } = this.props;\n\t\tlet xScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([0, width - 2 * padding]);\n\n\t\tlet yScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([height - 2 * padding, 0]);\n\t\tconst svg = d3.select(\"#nice\").select(\"svg\");\n\t\tlet dataSet = [];\n\t\tfor (let i = 0; i < X.length; i++) {\n\t\t\tdataSet.push({\n\t\t\t\tx: xScale(X[i]),\n\t\t\t\ty: yScale(y[i]),\n\t\t\t});\n\t\t}\n\t\tlet a = [];\n\t\tfor (let i = 0; i < X.length; i++) {\n\t\t\ta.push([xScale(X[i]), yScale(yhat[i])]);\n\t\t}\n\t\tsvg.selectAll(\"circle\").remove();\n\t\tthis.plotPoints(svg, dataSet);\n\n\t\tsvg.select(\"#epic\")\n\t\t\t.attr(\"d\", d3.line()(a))\n\t\t\t.attr(\"stroke\", \"black\")\n\t\t\t.attr(\"fill\", \"none\");\n\t}\n\t//componentDidUpdate() {\n\t//const { width, height, padding, start, stop, X, y } = this.props;\n\t//console.log(X);\n\t//console.log(y);\n\t//let xScale = d3\n\t//.scaleLinear()\n\t//.domain([start, stop])\n\t//.range([0, width - 2 * padding]);\n\n\t//let yScale = d3\n\t//.scaleLinear()\n\t//.domain([start, stop])\n\t//.range([height - 2 * padding, 0]);\n\t//const svg = d3.select(\"#nice\").select(\"svg\");\n\t//let dataSet = [];\n\t//for (let i = 0; i < X.length; i++) {\n\t//dataSet.push({\n\t//x: xScale(X[i]),\n\t//y: yScale(y[i]),\n\t//});\n\t//}\n\t///* Now need to plot said data */\n\t//svg.selectAll(\"circle\")\n\t//.data(dataSet)\n\t//.enter()\n\t//.append(\"circle\")\n\t//.attr(\"cx\", (d) => d.x)\n\t//.attr(\"cy\", (d) => d.y)\n\t//.attr(\"r\", 2)\n\t//.style(\"fill\", \"#F50257\");\n\t//}\n\trender() {\n\t\treturn <div id=\"nice\"></div>;\n\t}\n}\n\nexport default ScatterPlot;\n","/* \n  Donny Bertucci: @xnought\n  Date Created: 02/15/2021\n  Summary: \n    This file acts as the highest state and act as the controls \n    for the entire application\n*/\nimport React, { Component } from \"react\";\nimport {\n\tTypography,\n\tInput,\n\tBox,\n\tAppBar,\n\tToolbar,\n\tCard,\n\tCardContent,\n\tIconButton,\n\tCardActions,\n\tChip,\n\tTextField,\n\tButton,\n} from \"@material-ui/core\";\nimport { PlusOne, Replay, SlowMotionVideo, Add } from \"@material-ui/icons\";\nimport style from \"./App.css\";\nimport PlayButton from \"./components/PlayButton\";\nimport NN from \"./components/NN\";\nimport ScatterPlot from \"./components/ScatterPlot\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport * as d3 from \"d3\";\n\nclass App extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\t/* Treat the app state as the global state */\n\t\tthis.state = {\n\t\t\t/* data: stores the input and lables to the input */\n\t\t\tX: null,\n\t\t\ty: null,\n\t\t\tyhat: [],\n\t\t\tbiasData: [],\n\t\t\tweightsData: [],\n\t\t\tdata: {\n\t\t\t\tX: [],\n\t\t\t\ty: [],\n\t\t\t},\n\t\t\t/* Stores the model and model metadata */\n\t\t\tmodel: {\n\t\t\t\tseq: {},\n\t\t\t\tneurons: [],\n\t\t\t\tshape: [1, 4, 4, 1],\n\t\t\t\tloss: null,\n\t\t\t\ty: null,\n\t\t\t\tyhat: [],\n\t\t\t\tdlossdyhat: null,\n\t\t\t\tepoch: 0,\n\t\t\t\tlr: 0.01,\n\t\t\t\tcurve: \"sin\",\n\t\t\t\toptimizer: \"adam\",\n\t\t\t\tscale: 5,\n\t\t\t},\n\t\t\t/* Stores the controls */\n\t\t\tcontrols: {\n\t\t\t\tplaying: false,\n\t\t\t\tspeed: 0,\n\t\t\t},\n\t\t};\n\n\t\t/* Prototype: Functions Binds to \"this\" */\n\t\t/* Main Logic */\n\t\tthis.main = this.main.bind(this);\n\t\tthis.run = this.run.bind(this);\n\t\t/* Neural Network Logic */\n\t\tthis.neuralNetwork = this.neuralNetwork.bind(this);\n\t\t/* Intialization */\n\t\tthis.initDenseNeuron = this.initDenseNeuron.bind(this);\n\t\tthis.initializeModel = this.initializeModel.bind(this);\n\t\tthis.linkModel = this.linkModel.bind(this);\n\t\t/* Epoch calculations */\n\t\tthis.forwardModel = this.forwardModel.bind(this);\n\t\tthis.backwardModel = this.backwardModel.bind(this);\n\t\tthis.updateModel = this.updateModel.bind(this);\n\t\tthis.setInputs = this.setInputs.bind(this);\n\t\t/* Activation Functions */\n\t\t/* Tools for forward */\n\t\t/* Loss Functions */\n\t\t/* Data Generation */\n\t\tthis.generateData = this.generateData.bind(this);\n\t\tthis.genTensorData = this.genTensorData.bind(this);\n\t\tthis.linearData = this.linearData.bind(this);\n\t\t/* Mutators of State */\n\t\tthis.mutate = this.mutate.bind(this);\n\t\tthis.mutateModelNeurons = this.mutateModelNeurons.bind(this);\n\t\tthis.passBack = this.passBack.bind(this);\n\n\t\tthis.mutateAllBackward = this.mutateAllBackward.bind(this);\n\t\tthis.train = this.train.bind(this);\n\t\tthis.printParameters = this.printParameters.bind(this);\n\t\tthis.reset = this.reset.bind(this);\n\t\tthis.asyncPause = this.asyncPause.bind(this);\n\t\tthis.resetParameters = this.resetParameters.bind(this);\n\t\tthis.changeModelLr = this.changeModelLr.bind(this);\n\t\tthis.changeModelOptimizer = this.changeModelOptimizer.bind(this);\n\t}\n\tasync changeModelOptimizer(optimizerChange) {\n\t\tlet model = await this.modelCompile(\n\t\t\toptimizerChange,\n\t\t\tthis.state.model.lr\n\t\t);\n\t\tthis.mutate(\"model\", \"seq\", model);\n\t}\n\n\tchangeModelLr(lrChange) {\n\t\tlet model = this.state.model.seq;\n\t\tmodel.optimizer_.learningRate = lrChange;\n\t\tthis.mutate(\"model\", \"seq\", model);\n\t}\n\t/* not binded to \"this\" functions */\n\tReLU(number) {\n\t\treturn Math.max(0, number);\n\t}\n\tmseDerivative(yhat, y) {\n\t\treturn 2 * (yhat - y);\n\t}\n\tmseLoss(yhat, y) {\n\t\treturn Math.pow(yhat - y, 2);\n\t}\n\tmult(array1, array2) {\n\t\treturn array1.map((item, i) => {\n\t\t\treturn item * array2[i];\n\t\t});\n\t}\n\tsum(array) {\n\t\treturn array.reduce((a, b) => a + b);\n\t}\n\tgetRandomInt(max) {\n\t\treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\t/* \n    Name: main\n    Purpose: mutate all the values seen to user by delay of this.state.controls.speed \n    @mutate: this.state.model\n  */\n\tasync main() {\n\t\tconst timer = (ms) => new Promise((res) => setTimeout(res, ms));\n\t\t/* Until broken by user */\n\t\twhile (true) {\n\t\t\t/* Destructure neccesary state */\n\t\t\tconst { controls, model } = this.state;\n\t\t\tconst { playing, speed } = controls;\n\n\t\t\tif (playing === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait timer(speed);\n\t\t\t/* this.nerualNetwork(model) */\n\t\t\tawait this.neuralNetwork();\n\t\t\tthis.mutate(\"model\", \"epoch\", model.epoch + 1);\n\t\t}\n\t}\n\n\t/* \n    Name: start\n    Purpose: start the main logic and choose to stop\n    @mutate: this.state.controls.playing\n  */\n\tasync run() {\n\t\tthis.mutate(\"controls\", \"playing\", !this.state.controls.playing);\n\t\tawait this.train(this.state.X, this.state.y);\n\t\t//await this.main();\n\t}\n\n\tasync neuralNetwork() {\n\t\t/* Add the inputs to the first input neuron */\n\t\tawait this.forwardModel(this.getRandomInt(this.state.data.X.length));\n\t\tawait this.backwardModel();\n\t\tawait this.updateModel();\n\t\t// await this.backwardModel(model);\n\t\t// await this.updateModel(model);\n\t}\n\n\t/* \n    Name: initializeModel\n    Purpose: to invoke generation of data and initializing the neural network model\n    @mutate: this.model\n  */\n\tasync initializeModel(shape, start, stop, increment, eqn) {\n\t\t/* Generate Data and set this.state.data*/\n\t\tthis.generateData(start, stop, increment, eqn);\n\t\t// let newsShape = [0, 1, 3, 3, 1];\n\t\t// const numLayers     1  2  3  4 = 4\n\t\tlet newShape = [0, ...shape];\n\t\tconst numLayers = newShape.length;\n\n\t\t/* Define the model */\n\t\t/* [[neuron], [neuron, neuron, neuron],[neuron, neuron, neuron], [neuron]] model: [1,3,3,1] shape */\n\t\tlet model = [];\n\n\t\t/* Add input neuron to the model */\n\t\tfor (let i = 1; i < numLayers; i++) {\n\t\t\t/* Initialize layer */\n\t\t\tlet layer = [];\n\t\t\t/* Get the number of neurons to generate */\n\t\t\tlet numNeurons = newShape[i];\n\t\t\t/* Add neurons to the to the layer */\n\t\t\tfor (let e = 0; e < numNeurons; e++) {\n\t\t\t\t/* Number of inputs from the previous layer to devlay Neuron */\n\t\t\t\tlet neuron = this.initDenseNeuron(newShape[i - 1]);\n\t\t\t\t/* Push to layer */\n\t\t\t\tlayer.push(neuron);\n\t\t\t}\n\t\t\t/* Add to the model */\n\t\t\tmodel.push(layer);\n\t\t}\n\n\t\t/* update the state */\n\t\tthis.mutate(\"model\", \"neurons\", model);\n\t\tthis.mutate(\"model\", \"shape\", shape);\n\t}\n\n\t/* \n    Name: initDenseNeuron\n    @param: numInputs\n    @return: intialized neuron object \n  */\n\tinitDenseNeuron(numInputs) {\n\t\tlet DenseNeuronTemplate = {\n\t\t\tforward: {\n\t\t\t\tinputs: [],\n\t\t\t\tweights: [],\n\t\t\t\tbias: null,\n\t\t\t\tproduct: [],\n\t\t\t\tsum: null,\n\t\t\t\tactivation: null,\n\t\t\t\toutput: null,\n\t\t\t},\n\t\t\tbackward: {\n\t\t\t\tdvalue: null,\n\t\t\t\tdReLU: null,\n\t\t\t\tdBias: null,\n\t\t\t\tdMult: [],\n\t\t\t\tdWeights: [],\n\t\t\t\tdInputs: [],\n\t\t\t\tdNeuron: null,\n\t\t\t},\n\t\t\tlinks: [],\n\t\t};\n\t\tfor (let i = 0; i < numInputs; i++) {\n\t\t\tlet number =\n\t\t\t\t0.1 * (Math.random() < 0.5 ? -Math.random() : Math.random());\n\t\t\t//let number = Math.random();\n\t\t\tDenseNeuronTemplate.forward.weights.push(number);\n\t\t}\n\t\tDenseNeuronTemplate.forward.bias = 0;\n\t\tDenseNeuronTemplate.links = this.linkModel(numInputs);\n\n\t\treturn DenseNeuronTemplate;\n\t}\n\n\tlinkModel(numInputs) {\n\t\treturn this.linearData(0, numInputs - 1, 1);\n\t}\n\n\t/* \n    Name: forwardModel\n    Purpose: one forward pass \n    @mutate: this.model\n  */\n\tasync forwardModel(index) {\n\t\t/* Destructure State */\n\t\tconst { data, model } = this.state;\n\t\tconst { neurons, shape } = model;\n\n\t\t//const index = 1;\n\t\tlet X = [data.X[index]];\n\t\tthis.setInputs(X, 0);\n\t\t/* First perform one forward pass */\n\t\t/* iterate non-input layers */\n\t\tlet io = X;\n\t\tfor (let layer = 1; layer < shape.length; layer++) {\n\t\t\t/* Pass the values from the last neuron */\n\t\t\tthis.setInputs(io, layer);\n\t\t\tio = [];\n\t\t\t/* iterate neuron */\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\tlet { weights, inputs, bias } = neurons[layer][neuron].forward;\n\t\t\t\tlet mult = this.mult(weights, inputs);\n\t\t\t\tlet sum = this.sum(mult) + bias;\n\t\t\t\tif (layer != shape.length - 1) {\n\t\t\t\t\tlet relu = this.ReLU(sum);\n\t\t\t\t}\n\t\t\t\tlet relu = sum;\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"product\",\n\t\t\t\t\tmult,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tthis.mutateModelNeurons(\"forward\", \"sum\", sum, layer, neuron);\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"activation\",\n\t\t\t\t\trelu,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"output\",\n\t\t\t\t\trelu,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tio.push(relu);\n\t\t\t}\n\t\t}\n\t\t/* Calculate loss */\n\t\tconst yhat = this.state.model.neurons[shape.length - 1][0].forward\n\t\t\t.output;\n\t\tlet loss = this.mseLoss(yhat, data.y[index]);\n\t\tthis.mutate(\"model\", \"y\", data.y[index]);\n\t\tthis.mutate(\"model\", \"yhat\", yhat);\n\t\tthis.mutate(\"model\", \"loss\", loss);\n\n\t\t//console.log(`yhat: ${this.state.model.yhat}`);\n\t\t//console.log(`y: ${this.state.data.y[index]}`);\n\t\t//console.log(this.state.model.loss);\n\t}\n\n\t/* \n\t\tName: mutateAllBackward\n\t\t@mutate: this.model.neurons[layer][neuron].backward\n\t*/\n\tmutateAllBackward(\n\t\tdReLU,\n\t\tdBias,\n\t\tdMult,\n\t\tdWeights,\n\t\tdInputs,\n\t\tdNeuron,\n\t\tlayer,\n\t\tneuron\n\t) {\n\t\tthis.mutateModelNeurons(\"backward\", \"dReLU\", dReLU, layer, neuron);\n\t\tthis.mutateModelNeurons(\"backward\", \"dBias\", dBias, layer, neuron);\n\t\tthis.mutateModelNeurons(\"backward\", \"dMult\", dMult, layer, neuron);\n\t\tthis.mutateModelNeurons(\n\t\t\t\"backward\",\n\t\t\t\"dWeights\",\n\t\t\tdWeights,\n\t\t\tlayer,\n\t\t\tneuron\n\t\t);\n\t\tthis.mutateModelNeurons(\"backward\", \"dInputs\", dInputs, layer, neuron);\n\t\tthis.mutateModelNeurons(\"backward\", \"dNeuron\", dNeuron, layer, neuron);\n\t}\n\n\tpassBack(dvalue, currentLayer) {\n\t\tconst { shape } = this.state.model;\n\t\tconst prevLayer = currentLayer - 1;\n\t\tfor (let neuron = 0; neuron < shape[prevLayer]; neuron++) {\n\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\"backward\",\n\t\t\t\t\"dvalue\",\n\t\t\t\tdvalue,\n\t\t\t\tprevLayer,\n\t\t\t\tneuron\n\t\t\t);\n\t\t}\n\t}\n\t/* \n    Name: backwardModel\n    Purpose: compute derivative backwards\n    @mutate: this.model\n  */\n\tasync backwardModel() {\n\t\t/* Destructure the state */\n\t\tconst { model } = this.state;\n\n\t\t/* Destructure model */\n\t\tconst { yhat, y, shape } = model;\n\n\t\tlet outputLayerIndex = shape.length - 1;\n\t\t/* Calculate the loss derivative and pass it to the output neuron */\n\t\tlet dyhat = this.mseDerivative(yhat, y);\n\t\tthis.mutateModelNeurons(\n\t\t\t\"backward\",\n\t\t\t\"dvalue\",\n\t\t\tdyhat,\n\t\t\toutputLayerIndex,\n\t\t\t0\n\t\t);\n\n\t\t/* calculate each layer until we hit the layer before input layer */\n\t\tfor (let layer = outputLayerIndex; layer > 0; layer--) {\n\t\t\tlet dNeurons = [];\n\t\t\tlet dNeuronsSum = 0;\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t/* Destructure neccesary items from model forward and backward per neuron */\n\t\t\t\tlet { backward, forward } = model.neurons[layer][neuron];\n\t\t\t\tlet { inputs, weights, activation } = forward;\n\t\t\t\tlet { dvalue } = backward;\n\n\t\t\t\tlet dReLU = Math.max(0, activation) * dvalue;\n\t\t\t\tlet dBias = dReLU;\n\t\t\t\tif (layer == outputLayerIndex) {\n\t\t\t\t\tdReLU = dvalue;\n\t\t\t\t}\n\t\t\t\tlet dMult = inputs.map(() => dReLU);\n\t\t\t\tlet dWeights = this.mult(inputs, dMult);\n\t\t\t\tlet dInputs = this.mult(weights, dMult);\n\t\t\t\tlet dNeuron = this.sum(dInputs);\n\n\t\t\t\t/* Add all to the state of the neuron */\n\t\t\t\tthis.mutateAllBackward(\n\t\t\t\t\tdReLU,\n\t\t\t\t\tdBias,\n\t\t\t\t\tdMult,\n\t\t\t\t\tdWeights,\n\t\t\t\t\tdInputs,\n\t\t\t\t\tdNeuron,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\n\t\t\t\t/* Then we want to add dNeuron to an array */\n\t\t\t\tdNeurons.push(dNeuron);\n\t\t\t\t//console.log(`Layer: ${layer}, Neuron: ${neuron}`);\n\t\t\t\t//console.log(backward);\n\t\t\t\t//console.log(forward);\n\t\t\t}\n\t\t\t/* Sum the dNeuron array */\n\t\t\tdNeuronsSum = this.sum(dNeurons);\n\t\t\t/* Pass back the sum to the next layer */\n\t\t\tthis.passBack(dNeuronsSum, layer);\n\t\t}\n\t\t//console.log(this.state.model.neurons);\n\n\t\t/* Given current layer I want to pass back to previous layer */\n\t\t//this.passBack(dvalue, layer);\n\t\t//console.log(neurons[layer - 1]);\n\n\t\t///* Start at last layer */\n\t\t//for(let layer = shape.length - 1; layer >= 0; layer-- )\n\t\t//{\n\t\t//let dNeuronArray = [];\n\t\t//let dvalueSumLayer = 0;\n\t\t///* Itererate through each neuron per layer */\n\t\t//for(let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t///* Destructure Neuron */\n\t\t//let { activation, weights, inputs } = neurons[layer][neuron].forward;\n\t\t//let inputLength = inputs.length;\n\n\t\t//}\n\t\t//}\n\n\t\t///* Destructure Neuron */\n\t\t//let { activation, weights, inputs } = neurons[layer][neuron].forward;\n\t\t//let inputLength = inputs.length;\n\n\t\t//let lastNeuron = neurons[layer][neuron];\n\t\t///* Calculate the loss derivative */\n\t\t//let dyhat = this.mseDerivative(yhat, y);\n\n\t\t///* Sum the values needed to pass back */\n\t\t//let dNeuronArray = [];\n\t\t//let dvalueNextLayer = 0;\n\n\t\t///* Pass the value back*/\n\t\t//let dvalue = dyhat;\n\t\t//let dReLU = Math.max(0, activation) * dvalue;\n\t\t//let dBias = dReLU;\n\t\t//let dMult = inputs.map(() => dReLU);\n\t\t//let dWeights = this.mult(inputs, dMult);\n\t\t//let dInputs = this.mult(weights, dMult);\n\t\t//let dNeuron = this.sum(dInputs);\n\t\t///* Add dNeuron to the layers output */\n\t\t//dNeuronArray.push(dNeuron);\n\n\t\t///* At the end of first loop of layer iteration */\n\t\t//dvalueNextLayer = this.sum(dNeuronArray);\n\n\t\t//console.log(lastNeuron);\n\t\t///* Pass the derivative input back */\n\t\t//this.mutateAllBackward(\n\t\t//dvalue,\n\t\t//dReLU,\n\t\t//dBias,\n\t\t//dMult,\n\t\t//dWeights,\n\t\t//dInputs,\n\t\t//dNeuron,\n\t\t//layer,\n\t\t//neuron\n\t\t//);\n\t\t/* Update all of the parameters */\n\t\t//console.log(`dinput: ${dvalue}`);\n\t\t//console.log(`Activation: ${activation}`);\n\t\t//console.log(`dReLU: ${dReLU}`);\n\t\t//console.log(`DBias: ${dBias}`);\n\t\t//console.log(`DMult: [${dMult.toString()}]`);\n\t\t//console.log(`Dweights: [${dWeights.toString()}]`);\n\t\t//console.log(`Dinputs: [${dInputs.toString()}]`);\n\t\t//this.mutateModelNeurons(\n\t\t//\"backward\",\n\t\t//\"dprevNeurondLoss\",\n\t\t//dlossdyhat,\n\t\t//shape.length - 1,\n\t\t//0\n\t\t//);\n\n\t\t/* Pass back to neurons based on linkage */\n\t\t/* We want to now pass it back to the last neuron */\n\n\t\t/* Compute Derivative of loss */\n\t\t/* Iterate backwards of neurons */\n\t\t/* Compute derivative of a neuron */\n\t\t/* print the derivatives */\n\t}\n\n\tgradientDescent(lr, param, dparam) {\n\t\treturn param - lr * dparam;\n\t}\n\t/* \n    Name: updateModel\n    Purpose: to perform gradient descent and update the weights\n    @mutate: this.model\n  */\n\tasync updateModel() {\n\t\t/* Destructuring the state */\n\t\tconst { model } = this.state;\n\n\t\tconst { shape, lr, neurons } = model;\n\t\t/* Use the derivatives to perform gradient descent */\n\t\t/* Iterate through each and subtract weights by itself times the derivative of weights or biases */\n\t\tfor (let layer = 1; layer < shape.length; layer++) {\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\tlet { weights, bias } = neurons[layer][neuron].forward;\n\t\t\t\tlet { dWeights, dBias } = neurons[layer][neuron].backward;\n\t\t\t\t//*  */console.log(`Layer ${layer}, Neuron: ${neuron}`);\n\t\t\t\t/* Update weights */\n\t\t\t\tlet updatedWeights = [];\n\t\t\t\tfor (let weight = 0; weight < shape[layer - 1]; weight++) {\n\t\t\t\t\tupdatedWeights.push(\n\t\t\t\t\t\tthis.gradientDescent(\n\t\t\t\t\t\t\tlr,\n\t\t\t\t\t\t\tweights[weight],\n\t\t\t\t\t\t\tdWeights[weight]\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t/* Update bias */\n\t\t\t\tlet updatedBias = this.gradientDescent(lr, bias, dBias);\n\n\t\t\t\t/* Update the model weights and biases */\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"weights\",\n\t\t\t\t\tupdatedWeights,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"bias\",\n\t\t\t\t\tupdatedBias,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t/* We want to start from the beginning and subt */\n\t}\n\t/* \n    Name: setInputs\n    @param: inputs\n    @param: currentLayer\n    @mutate: this.state.model.neurons[currentLayer]\n  */\n\tsetInputs(inputs, currentLayer) {\n\t\t/* Destructure the neurons */\n\t\tconst { neurons } = this.state.model;\n\t\t/* Iterate through each neuron and set its inputs */\n\t\tfor (let i = 0; i < neurons[currentLayer].length; i++) {\n\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\"forward\",\n\t\t\t\t\"inputs\",\n\t\t\t\tinputs,\n\t\t\t\tcurrentLayer,\n\t\t\t\ti\n\t\t\t);\n\t\t}\n\t}\n\n\t/* \n    Name: generateData\n    @param: start\n    @param: end\n    @param increment\n    @param: equation (a function the user passes in)\n    @mutate: this.data\n  */\n\tgenerateData(start, stop, increment, equation) {\n\t\tif (typeof equation === \"function\" && equation(start) !== undefined) {\n\t\t\t/* Create the X input data */\n\t\t\tconst X = this.linearData(start, stop, increment);\n\t\t\t/* Create the labels to the input data */\n\t\t\tconst y = X.map((input) => {\n\t\t\t\treturn equation(input).toFixed(3);\n\t\t\t});\n\t\t\t/* Set State */\n\t\t\tthis.mutate(\"data\", \"X\", X);\n\t\t\tthis.mutate(\"data\", \"y\", y);\n\t\t} else {\n\t\t\tconsole.error(\n\t\t\t\t\"Enter a valid equation: must be function with input parameter that returns a number\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/* \n    Name: linearData\n    @param: start\n    @param: end\n    @param increment\n    @return: output array\n  */\n\tlinearData(start, end, increment) {\n\t\tlet output = [];\n\t\tfor (let i = start; i <= end; i += increment) {\n\t\t\toutput.push(i);\n\t\t}\n\t\treturn output;\n\t}\n\n\t/* \n    Name: mutate\n    @param key: corresponds to this.state.key\n    @param subkey: corresponds to this.state.key.subkey\n    @param value\n    @mutate: this.state.key.subkey with value\n  */\n\tmutate(key, subkey, value) {\n\t\t/* copy of the state */\n\t\tlet state = { ...this.state };\n\t\t/* If this.state.key.subkey exists */\n\t\tif (key in state && subkey in state[key]) {\n\t\t\t/* Mutate the state */\n\t\t\tstate[key][subkey] = value;\n\t\t\tthis.setState({ state });\n\t\t} else {\n\t\t\tconsole.error(\"Could not be found in state\");\n\t\t}\n\t}\n\n\t/* \n    Name: mutateModelNeurons\n    @param key: corresponds to this.state.key\n    @param subkey: corresponds to this.state.key.subkey\n    @param value\n    @param layer\n    @param neuron\n    @mutate: this.state.key.subkey with value\n  */\n\tmutateModelNeurons(key, subkey, value, layer, neuron) {\n\t\t/* copy of the state */\n\t\tlet neurons = { ...this.state.model.neurons };\n\t\t/* If this.state.key.subkey exists */\n\t\tif (neurons[layer][neuron][key][subkey] !== undefined) {\n\t\t\t/* Mutate the state */\n\t\t\tneurons[layer][neuron][key][subkey] = value;\n\t\t\tthis.setState({\n\t\t\t\t...this.state,\n\t\t\t\tmodel: { ...this.state.model, neurons: neurons },\n\t\t\t});\n\t\t} else {\n\t\t\tconsole.error(\"Could not be found in state\");\n\t\t}\n\t}\n\tpredicitons() {\n\t\tconst { data } = this.state;\n\t\tfor (let i = 0; i < data.X.length; i++) {\n\t\t\tthis.forwardModel();\n\t\t}\n\t}\n\n\ttensorToArray(tensor) {\n\t\treturn Array.from(tensor.dataSync());\n\t}\n\n\tasync addModel(model) {\n\t\tlet shape = this.state.model.shape;\n\t\tmodel.add(\n\t\t\ttf.layers.dense({\n\t\t\t\tinputShape: [1],\n\t\t\t\tunits: shape[1],\n\t\t\t\tactivation: \"relu\",\n\t\t\t\tuseBias: true,\n\t\t\t})\n\t\t);\n\t\tfor (let layer = 2; layer < shape.length - 1; layer++) {\n\t\t\tmodel.add(\n\t\t\t\ttf.layers.dense({\n\t\t\t\t\tunits: shape[layer],\n\t\t\t\t\tactivation: \"relu\",\n\t\t\t\t\tuseBias: true,\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tmodel.add(\n\t\t\ttf.layers.dense({ units: 1, activation: \"linear\", useBias: true })\n\t\t);\n\n\t\treturn model;\n\t}\n\tasync modelCompile(optimizer, lr) {\n\t\tlet model = tf.sequential();\n\t\tawait this.addModel(model);\n\t\tmodel.compile({\n\t\t\toptimizer: optimizer(lr),\n\t\t\tloss: \"meanSquaredError\",\n\t\t});\n\t\treturn model;\n\t}\n\tasync train(X, y) {\n\t\tlet { model } = this.state.model.seq;\n\t\t//await model.fit(X, y, { epochs: 1000 });\n\t\t//model.predict(X);\n\t\t//console.log(yArr);\n\t\t//console.log(XArr);\n\t\tconst timer = (ms) => new Promise((res) => setTimeout(res, ms));\n\t\t/* Until broken by user */\n\t\tlet play = this.state.controls.playing;\n\t\twhile (play !== false) {\n\t\t\t/* Destructure neccesary state */\n\t\t\tconst { playing, speed } = this.state.controls;\n\t\t\tconst { epoch } = this.state.model;\n\t\t\tplay = playing;\n\t\t\tif (play != false) {\n\t\t\t\tthis.mutate(\"model\", \"epoch\", epoch + 1);\n\t\t\t\tconst h = await model.fit(X, y, {\n\t\t\t\t\tepochs: 1,\n\t\t\t\t});\n\t\t\t\tawait this.printParameters(model);\n\t\t\t\tthis.mutate(\"model\", \"loss\", h.history.loss[0]);\n\t\t\t\tlet yhat = model.predict(X);\n\t\t\t\tthis.mutate(\"model\", \"yhat\", this.tensorToArray(yhat));\n\t\t\t\tawait timer(speed);\n\t\t\t}\n\t\t\t/* this.nerualNetwork(model) */\n\t\t}\n\t}\n\tasync genTensorData(eqn, scaled) {\n\t\tawait tf.ready();\n\t\tlet XTensor = tf.linspace(\n\t\t\t-this.state.model.scale,\n\t\t\tthis.state.model.scale,\n\t\t\t40\n\t\t);\n\t\tlet yTensor;\n\t\tyTensor = tf.mul(eqn(XTensor), scaled);\n\t\tlet yhatTensor = tf.zerosLike(XTensor);\n\t\tlet X = this.tensorToArray(XTensor);\n\t\tlet y = this.tensorToArray(yTensor);\n\t\tlet yhat = this.tensorToArray(yhatTensor);\n\n\t\tthis.setState({\n\t\t\t...this.state,\n\t\t\tX: XTensor,\n\t\t\ty: yTensor,\n\t\t\tdata: { X, y },\n\t\t\tmodel: { ...this.state.model, yhat },\n\t\t});\n\t}\n\tasync printParameters(model) {\n\t\tlet weightSet = [];\n\t\tlet biasSet = [];\n\t\tfor (let i = 0; i < model.getWeights().length; i++) {\n\t\t\t(i % 2 == 0 ? weightSet : biasSet).push(\n\t\t\t\tArray.from(model.getWeights()[i].dataSync())\n\t\t\t);\n\t\t}\n\t\tthis.setState({\n\t\t\t...this.state,\n\t\t\tbiasData: biasSet,\n\t\t\tweightsData: weightSet,\n\t\t});\n\t\t//for (let layer = 1; layer < model.layers.length; layer++) {\n\t\t//console.log(`Layer: ${layer} `);\n\t\t//model.layers[layer].getWeights()[0].print();\n\n\t\t//model.layers[layer].getWeights()[1].print();\n\t\t//}\n\t}\n\tasync asyncPause() {\n\t\tthis.mutate(\"controls\", \"playing\", false);\n\t}\n\tasync resetParameters(scale) {\n\t\tlet eqn;\n\t\tlet optimizer;\n\t\tif (this.state.model.curve === \"sin\") {\n\t\t\teqn = tf.sin;\n\t\t} else if (this.state.model.curve === \"tanh\") {\n\t\t\teqn = tf.tanh;\n\t\t} else if (this.state.model.curve === \"cos\") {\n\t\t\teqn = tf.cos;\n\t\t}\n\t\tif (this.state.model.optimizer == \"adam\") {\n\t\t\toptimizer = tf.train.adam;\n\t\t} else if (this.state.model.optimizer == \"sgd\") {\n\t\t\toptimizer = tf.train.sgd;\n\t\t}\n\t\tawait this.genTensorData(eqn, scale);\n\t\tlet model = await this.modelCompile(optimizer, this.state.model.lr);\n\t\tawait this.printParameters(model);\n\t\tthis.setState({\n\t\t\t...this.state,\n\t\t\tmodel: { ...this.state.model, seq: model, epoch: 0, loss: null },\n\t\t});\n\t}\n\n\tasync reset(scale) {\n\t\tawait this.asyncPause();\n\t\tawait this.resetParameters(scale);\n\t\t//;this.mutate(\"model\", \"seq\", model);\n\t\t//;this.setState({ yhat: [] });\n\t\t//;this.mutate(\"model\", \"epoch\", 0);\n\t}\n\tasync componentDidMount() {\n\t\t/* First lets choose the data */\n\t\tawait this.genTensorData(tf.sin, this.state.model.scale);\n\t\tlet model = await this.modelCompile(tf.train.adam, this.state.model.lr);\n\t\tthis.mutate(\"model\", \"seq\", model);\n\t\tthis.printParameters(model);\n\n\t\t//model.optimizer_ = tf.train.sgd(0.1);\n\t\t//model.optimizer_.learningRate = 0.001;\n\n\t\t//const paths = d3\n\t\t//.select(\"#app\")\n\t\t//.select(\"#nn\")\n\t\t//.selectAll(\"path\")\n\t\t//.attr(\"class\", \"edge\");\n\t\t//epochs: 10,\n\t\t//});\n\t\t//console.log(this.tensorToArray(model.predict(X)));\n\t\t//function lin(x) {\n\t\t//return x;\n\t\t//}\n\t\t//await this.initializeModel([1, 2, 2, 1], 0, 3.14, 1.57, Math.sin);\n\t\t//console.log(this.state.model.neurons);\n\t\t//await this.forwardModel();\n\t\t////console.log(\"Foward Pass\");\n\t\t////console.log(this.state.model.neurons);\n\t\t////console.log(\"Backward Pass and Update\");\n\t\t//await this.backwardModel();\n\t\t//await this.updateModel();\n\t\t//console.log(this.state.model.neurons);\n\t\t//await this.forwardModel();\n\t\t//console.log(\"Foward Pass\");\n\t\t//console.log(this.state.model.neurons);\n\t\t//console.log(\"Backward Pass and Update\");\n\t\t//await this.backwardModel();\n\t\t//await this.updateModel();\n\t\t//console.log(this.state.model.neurons);\n\t}\n\n\trender() {\n\t\t/* Destructure State*/\n\t\tconst { model, controls } = this.state;\n\n\t\t/* Destructuring model */\n\t\tconst { epoch, loss, shape } = model;\n\n\t\tlet newShape = [...shape];\n\t\tnewShape.splice(0, 1);\n\t\tnewShape.splice(newShape.length - 1, 1);\n\t\t//console.log(newShape);\n\t\tconst lrs = [0.001, 0.01, 0.1, 0.3, (1.0).toFixed(1)];\n\t\tconst optimizers = [\"adam\", \"sgd\"];\n\t\tconst dataSets = [\n\t\t\t{ label: \"sin\", eqn: tf.sin, scale: 5 },\n\t\t\t{ label: \"cos\", eqn: tf.cos, scale: 5 },\n\t\t\t{ label: \"tanh\", eqn: tf.tanh, scale: 5 },\n\t\t];\n\n\t\t/* Destructuring of model */\n\n\t\t/* Destructure render */\n\t\tconst PlayButtonClick = (\n\t\t\t// eslint-disable-next-line\n\t\t\t<a\n\t\t\t\tonClick={async () => {\n\t\t\t\t\tawait this.run();\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<PlayButton playing={controls.playing} />\n\t\t\t</a>\n\t\t);\n\n\t\treturn (\n\t\t\t<div id=\"app\">\n\t\t\t\t<AppBar\n\t\t\t\t\tposition=\"static\"\n\t\t\t\t\tstyle={{ background: \"#f50257\", color: \"white\" }}\n\t\t\t\t>\n\t\t\t\t\t<Toolbar>\n\t\t\t\t\t\t<Typography variant=\"h6\">\n\t\t\t\t\t\t\tBackpropagation Visualizer\n\t\t\t\t\t\t</Typography>\n\t\t\t\t\t</Toolbar>\n\t\t\t\t</AppBar>\n\n\t\t\t\t<Box display=\"flex\" justifyContent=\"center\" marginTop={10}>\n\t\t\t\t\t<Box width={400}>\n\t\t\t\t\t\t<Card variant=\"outlined\">\n\t\t\t\t\t\t\t<CardContent>\n\t\t\t\t\t\t\t\t<Typography\n\t\t\t\t\t\t\t\t\tvariant=\"caption\"\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tcolor: \"rgb(245, 2, 87, 0.5)\",\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tControl Center\n\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t<Typography variant=\"h4\">\n\t\t\t\t\t\t\t\t\tEpochs: {epoch}\n\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t<Typography variant=\"h6\">\n\t\t\t\t\t\t\t\t\tloss: {loss == null ? \"\" : loss.toFixed(6)}\n\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t<IconButton\n\t\t\t\t\t\t\t\t\t\tdisabled={this.state.controls.playing}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tthis.reset(model.scale);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Replay />\n\t\t\t\t\t\t\t\t\t</IconButton>\n\t\t\t\t\t\t\t\t\t{PlayButtonClick}\n\t\t\t\t\t\t\t\t\t<IconButton\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tcolor:\n\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.speed == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"grey\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"#FFC006\",\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\"controls\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"speed\",\n\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.speed == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t? 100\n\t\t\t\t\t\t\t\t\t\t\t\t\t: 0\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<SlowMotionVideo />\n\t\t\t\t\t\t\t\t\t</IconButton>\n\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t</CardContent>\n\t\t\t\t\t\t</Card>\n\n\t\t\t\t\t\t<Box marginTop={5}>\n\t\t\t\t\t\t\t<Card variant=\"outlined\">\n\t\t\t\t\t\t\t\t<CardContent>\n\t\t\t\t\t\t\t\t\t<Typography\n\t\t\t\t\t\t\t\t\t\tvariant=\"caption\"\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tcolor: \"rgb(245, 2, 87, 0.5)\",\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tModel Initialization\n\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Typography variant=\"caption\">\n\t\t\t\t\t\t\t\t\t\t\tOptimizer\n\t\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t\t{optimizers.map((optimizer, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\tdisabled={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.playing\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\t\t\t\tlabel={optimizer}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.optimizer == optimizer\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"default\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"optimizer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toptimizer\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.changeModelOptimizer(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toptimizer == \"sgd\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? tf.train.sgd\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: tf.train.adam\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(model.scale);\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Typography variant=\"caption\">\n\t\t\t\t\t\t\t\t\t\t\tLearning Rate\n\t\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t\t{lrs.map((num, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\t\t\t\tlabel={`${num}`}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.model.lr ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${num}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"default\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"lr\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnum\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.changeModelLr(num);\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Typography variant=\"caption\">\n\t\t\t\t\t\t\t\t\t\t\tData Set\n\t\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t\t{dataSets.map((item, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\tdisabled={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.playing\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\t\t\t\tlabel={item.label}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.model.curve ==\n\t\t\t\t\t\t\t\t\t\t\t\t\titem.label\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"default\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(model.scale);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"curve\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titem.label\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.genTensorData(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titem.eqn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titem.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t</CardContent>\n\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t</Box>\n\t\t\t\t\t</Box>\n\t\t\t\t\t<Box marginLeft={10}>\n\t\t\t\t\t\t<NN\n\t\t\t\t\t\t\tweights={this.state.weightsData}\n\t\t\t\t\t\t\tbiases={this.state.biasData}\n\t\t\t\t\t\t\tshape={this.state.model.shape}\n\t\t\t\t\t\t\tplaying={this.state.controls.playing}\n\t\t\t\t\t\t\tslowed={this.state.controls.speed != 0}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Card variant=\"outlined\" style={{ minWidth: 875 }}>\n\t\t\t\t\t\t\t\t<Box justifyContent=\"start\" display=\"flex\">\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Box marginRight={11.5}>\n\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape = this.state.model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (!(shape.length > 4)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.log(shape);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.length - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.push(2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.push(1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\"path\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\"rect\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(5);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\tAdd Layer\n\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t{newShape.map((num, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Box marginRight={17}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Box marginBottom={1}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel={\"\"}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape = this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.state.model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet e = i + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? shape[e]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: shape[e] -\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t!shape[e] == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"path\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rect\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t\t\t<Box>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel={\"+\"}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape = this\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.state.model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet e = i + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] >= 8\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? shape[e]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: shape[e] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (shape[i] <= 8) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"path\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rect\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t))}\n\n\t\t\t\t\t\t\t\t\t\t<Box>\n\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape = this.state.model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (shape.length > 2) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.length - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.length - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.push(1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\"path\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\"rect\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(5);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\tRemove Layer\n\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t</NN>\n\t\t\t\t\t</Box>\n\t\t\t\t\t<Box marginLeft={10}>\n\t\t\t\t\t\t<ScatterPlot\n\t\t\t\t\t\t\twidth={300}\n\t\t\t\t\t\t\theight={300}\n\t\t\t\t\t\t\tpadding={0}\n\t\t\t\t\t\t\tstart={-this.state.model.scale}\n\t\t\t\t\t\t\tstop={this.state.model.scale}\n\t\t\t\t\t\t\tX={this.state.data.X}\n\t\t\t\t\t\t\ty={this.state.data.y}\n\t\t\t\t\t\t\tyhat={this.state.model.yhat}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Box>\n\t\t\t\t</Box>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}